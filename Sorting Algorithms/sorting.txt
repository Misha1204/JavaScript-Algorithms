Bubble Sort
###########

Bubble sort - მოქმედებს შემდეგნაირად. შეადარებს პირველ და მეორე მნიშვნელობებს სიაში, იმ შემთხვევაში, თუ მეორე მნიშვნელობა ნაკლებია პირველზე,
შეუცვლის მათ ადგილებს. ამის შემდეგ შეადარებს მეორე და მესამე მნიშვნელობებს და ა. შ. აღნიშნულ ალგორითმს, უმაღლესი მნიშვნელობები ნელ-ნელა გადაჰყავს
სიის ბოლოს. უნდა გავითვალისწინოთ, რომ ყოველი მომდევნო იტერაციისას, იმ ელემენტების რაოდენობა, რომელთა სორტირებაც უნდა მოხდეს მცირდება.

Big O Notation - Bubble Sort - ის Big O ძირითადად არის O(n2), მაგრამ იმ შემთხვევაში, თუ მონაცემები თითქმის სორტირებულია ან უკვე სორტირებულია Big O არის
O(n)

Selection Sort
##############

Selection Sort - მოქმედებს შემდეგნაირად. თითოეული იტერაციის დროს, სიის პირველივე წევრი იქნება მინიმალური მნიშვნელობა. აღნიშნულ მნიშვნელობას 
შეადარებს ყველა მნიშვნელობას და იმ შემთხვევაში, თუ იგი მართლაც მინიმალური აღმოჩნდება, მას ჩასვამს სიის დასაწყისში.

Big O Notation - Selection Sort - ის Big O არის O(n2). Bubble Sort - სგან განსხვავებით, შეგვიძლია გამოვიყენოთ იმ დროს როდესაც გვინდა, რომ 
ნაკლებად მოხდეს მნიშვნელობების პოზიციების გაცვლა.

Insertion Sort
##############

Insertion Sort - მოქმედებს შემდეგნაირად. ის სიას გადაუვლის მარცხნიდან მარჯვნივ, თავდაპირველად შეადარებს პირველ და მეორე წევრებს, იმ შემთხვევაში, თუ მეორე 
წევრი ნაკლებია პირველზე, შეუცვლის მათ ადგილებს, ამის შემდეგ შეადარებს მეორე და მესამე წევრებს, ხოლო იმ შემთხვევაში, თუ მესამე წევრი ნაკლებია მეორეზე ან
პირველზე მესამე წევრი დაიკავებს იმ ადგილს, სადაც უნდა იყოს თავისი მნიშვნელობიდან გამომდინარე. Insertion Sort კარგია იმ შემთხვევაში, თუ გვინდა რომ
ჩვენი სია განუწყვეტლივ სორტირდებოდეს და მას ემატება ახალი მონაცემები.

Big O Notation - Insertion Sort - ის Big O ძირითადად არის O(n2), მაგრამ იმ შემთხვევაში, თუ მონაცემები თითქმის სორტირებულია ან უკვე სორტირებულია Big O არის
O(n)

Merge Sort
##########

Merge Sort - მოქმედებს შემდეგნაირად. ის ყოფს სიას 2 ნაწილად იქამდე, სანამ სიაში არ დარჩება 1 ან 0 წევრი, დაშვება არის დამყარებული იმაზე, რომ 1 წევრიანი 
სია არის სორტირებული. შემდეგ სიის მარცხენა ნაწილს, merge ფუნქციის დახმარებით შეაერთებს მარჯვენა ნაწილთან და ასე გაგრძელდება სანამ არ მივიღებთ 
საბოლოოდ სორტირებულ სიას.

Big O Notation - Merge Sort - ის Big O ყოველთვის არის O(n log n). O(n log n) გულისხმობს იმას, რომ თავად mergeSort - ის ალგორითმს, იმ შემთხვევაში,
თუ თავდაპირველი სია შედგება 32 წევრისგან, სჭირდება 5 მოქმედება, რათა სია დაანაწევროს 1 წევრიან სიებად. თუმცა, აქვე უნდა გავითვალისწინოთ merge ფუნქცია
რომელსაც O(n) complexity აქვს. რაც უფრო მეტია წევრების რაოდენობა, მით დიდი დრო დასჭირდება merge ფუნქციას. Space complexity - არის O(n).

Quick Sort
##########

Quick Sort - მოქმედებს შემდეგნაირად - სიის პირველივე წევრს გაუტოლებს მინიმალურ მნიშვნელობას, ხოლო შემდეგ, გადაუვლის სიას და იმ წევრებს რომელთა
მნიშვნელობაც იქნება პირველ მნიშვნელობაზე ნაკლები, გადმოიტანს აღნიშნული მნიშვნელობის მარცხნივ. შემდეგ იგივენაირად დაასორტირებს მარცხენა და მარჯვენა
ნაწილებს.

Big O Notation - Quick Sort - ის Big O ძირითადად არის O(n log n), ყველაზე ცუდ შემთხვევაში კი შესაძლოა იყოს O(n2). Space complexity კი არის O(log n).

Radix Sort
##########

Radix Sort - მოქმედებს შემდეგნაირად - იგი ქმნის 9 სვეტს, რომლებსაც მინიჭებული აქვთ ინდექსები 0 დან 9 ის ჩათვლით. მთავარი იტერაცია ხორციელდება იმდენჯერ
რამხელაცაა სიის ყველაზე გრძელი წევრის სიგრძე. ის თავდაპირველად ერთეულების მიხედვით მოათავსებს რიცხვებს სვეტებში, შემდეგ ათეულების და ა.შ.
საბოლოოდ კი მივიღებთ სორტირებულ სიას.

Big O Notation - Radix Sort - ის Big O არის O(nk). ხოლო მისი Space complexity კი არის O(n+k).
